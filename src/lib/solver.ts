/**
 * Generated by ChatGPT!
 */

import { Operator } from './miscellaneous';
import groupBy from 'lodash.groupby';

interface Expression {
  expression: string;
  steps: number;
  numbersUsed: number;
}

function solveCountdownNumbers(target: number, numbers: number[]): Expression[] {
  const solutions: Expression[] = [];

  const backtrack = (
    currentValue: number,
    currentExpression: string,
    remainingNumbers: number[],
    currentSteps: number,
    numbersUsed: number
  ): void => {
    if (currentValue === target) {
      solutions.push({
        expression: currentExpression,
        steps: currentSteps,
        numbersUsed,
      });
      return;
    }

    if (remainingNumbers.length === 0) {
      return;
    }

    for (let i = 0; i < remainingNumbers.length; i++) {
      const number = remainingNumbers[i];
      const newRemainingNumbers = [...remainingNumbers];
      newRemainingNumbers.splice(i, 1);

      // Try all four basic arithmetic operations
      for (const operator of ['+', '-', '*', '/'] as Operator[]) {
        const newValue = applyOperator(currentValue, number, operator);
        const newExpression = currentExpression ? `(${currentExpression} ${operator} ${number})` : `${number}`;

        if (newValue > 9999 || newValue <= 0 || !Number.isInteger(newValue)) {
          continue;
        }

        backtrack(newValue, newExpression, newRemainingNumbers, currentSteps + (currentExpression ? 1 : 0), numbersUsed + 1);
      }
    }
  };

  backtrack(0, '', numbers, 0, 0);

  return solutions;
}

function applyOperator(a: number, b: number, operator: Operator): number {
  switch (operator) {
    case '+':
      return a + b;
    case '-':
      return a - b;
    case '*':
      return a * b;
    case '/':
      return a / b;
    default:
      throw new Error('Invalid operator');
  }
}

export class Solver {
  static findSolutions(numbers: number[], target: number) {
    const solutions = solveCountdownNumbers(target, numbers);

    const stepGroups = groupBy(solutions, 'steps');
    const fewestSteps = Object.keys(stepGroups)
      .map((n) => parseInt(n, 10))
      .sort((a, b) => (a < b ? -1 : 1))[0];

    const numbersUsedGroups = groupBy(solutions, 'numbersUsed');
    const fewestNumbersUsed = Object.keys(numbersUsedGroups)
      .map((n) => parseInt(n, 10))
      .sort((a, b) => (a < b ? -1 : 1))[0];

    return {
      solutions,
      fewestSteps: fewestSteps,
      fewestStepSolutions: stepGroups[fewestSteps],
      fewestNumbersUsed: fewestNumbersUsed,
      fewestNumbersUsedSolutions: numbersUsedGroups[fewestNumbersUsed],
    };
  }
}
